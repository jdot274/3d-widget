{"version":3,"sources":["Chip.js"],"names":["THREE","_interopRequireWildcard","require","_sceneConfig","_interopRequireDefault","_RoundedBoxGeometry","_MeshBeveledBoxGeometry","Chip","row","col","scene","_classCallCheck","this","isHovered","isAccented","initialPosition","Vector3","hoverPosition","config","hoverLift","originalScale","hoverScale","createMesh","updatePosition","mesh","userData","chip","originalPosition","position","clone","add","geometry","chipWidth","chipSpacing","chipHeight","chipDepth","cornerRadius","roundedCorners","RoundedBoxGeometry","beveledCorners","MeshBeveledBoxGeometry","BoxGeometry","e","material","MeshPhysicalMaterial","color","metalness","roughness","reflectivity","envMapIntensity","transmission","thickness","transparent","opacity","rotation","set","Math","random","gridSize","gridSpacing","x","spacing","y","copy","time","timeOffset","floatHeight","sin","floatSpeed","floatAmplitude","z","cos","gsap","to","duration","ease","emissiveIntensity","emissive","Color","scale","accentColor","r","g","b","baseColor","dispose"],"mappings":"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","file":"Chip.min.js","sourcesContent":["import * as THREE from 'three';\nimport config from '../scene.config.json';\n// Import with proper fallbacks - using synchronous imports for guaranteed loading\nimport { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';\nimport { MeshBeveledBoxGeometry } from './geometries/MeshBeveledBoxGeometry.js';\n\nclass Chip {\n  constructor(row, col, scene) {\n    this.row = row;\n    this.col = col;\n    this.scene = scene;\n    this.isHovered = false;\n    this.isAccented = false;\n    this.initialPosition = new THREE.Vector3(0, 0, 0);\n    this.hoverPosition = new THREE.Vector3(0, 0, config.hoverLift * 2);\n    this.originalScale = new THREE.Vector3(1, 1, 1);\n    this.hoverScale = new THREE.Vector3(1.1, 1.1, 1.1);\n    \n    // Create mesh with appropriate geometry and material\n    this.createMesh();\n    \n    // Position the mesh in the scene\n    this.updatePosition();\n    \n    // Save original position for animations\n    this.mesh.userData.chip = this;\n    this.mesh.userData.originalPosition = this.mesh.position.clone();\n    \n    // Add to scene\n    scene.add(this.mesh);\n  }\n\n  /*\n  loadMatcap() {\n    // Use a matcap texture for more realistic metal\n    try {\n      const textureLoader = new THREE.TextureLoader();\n      this.matcapTexture = this.createMatcapTexture(); // Start with the local version\n      \n      // Try to load a remote texture but don't fail if it doesn't work\n      textureLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/dancing_hall_1k.hdr', \n        // Success callback\n        (texture) => {\n          this.matcapTexture = texture;\n          if (this.material) {\n            this.material.envMap = texture;\n            this.material.needsUpdate = true;\n          }\n        },\n        // Progress callback\n        undefined,\n        // Error callback\n        (err) => {\n          console.warn('Failed to load external texture, using local fallback');\n        }\n      );\n    } catch (e) {\n      console.warn('Error in loadMatcap:', e);\n      this.matcapTexture = this.createMatcapTexture();\n    }\n  }\n  \n  createMatcapTexture() {\n    // Create a custom matcap texture for brushed metal\n    try {\n      const size = 1024;\n      const canvas = document.createElement('canvas');\n      canvas.width = size;\n      canvas.height = size;\n      const ctx = canvas.getContext('2d');\n      \n      // Create a radial gradient for a silver matcap\n      const gradient = ctx.createRadialGradient(\n        size * 0.4, size * 0.4, 0,\n        size * 0.5, size * 0.5, size * 0.7\n      );\n      \n      // Silver matcap with highlight\n      gradient.addColorStop(0, '#ffffff');\n      gradient.addColorStop(0.2, '#f0f0f0');\n      gradient.addColorStop(0.4, '#d0d0d0');\n      gradient.addColorStop(0.7, '#a0a0a0');\n      gradient.addColorStop(1, '#808080');\n      \n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, size, size);\n      \n      // Add brushed metal texture using noise lines\n      this.addBrushedMetalTexture(canvas, ctx, 0.1);\n      \n      // Create a texture from the canvas\n      const texture = new THREE.CanvasTexture(canvas);\n      texture.needsUpdate = true;\n      \n      return texture;\n    } catch (e) {\n      console.warn('Error in createMatcapTexture:', e);\n      return null;\n    }\n  }\n  \n  addBrushedMetalTexture(canvas, ctx, intensity) {\n    try {\n      const size = canvas.width;\n      const imageData = ctx.getImageData(0, 0, size, size);\n      const data = imageData.data;\n      \n      // Create brushed metal effect with horizontal lines\n      for (let y = 0; y < size; y++) {\n        // Vary the intensity slightly per line for more natural look\n        const lineIntensity = intensity * (0.8 + Math.random() * 0.4);\n        \n        // Create a noise pattern for this line\n        const noisePattern = [];\n        for (let x = 0; x < size / 10; x++) {\n          noisePattern.push((Math.random() - 0.5) * lineIntensity);\n        }\n        \n        for (let x = 0; x < size; x++) {\n          const idx = (y * size + x) * 4;\n          // Use interpolated noise for smoother brushed effect\n          const noiseIdx = Math.floor(x / 10);\n          const noiseValue = noisePattern[noiseIdx % noisePattern.length];\n          \n          data[idx] = Math.min(255, Math.max(0, data[idx] * (1 + noiseValue)));\n          data[idx+1] = Math.min(255, Math.max(0, data[idx+1] * (1 + noiseValue)));\n          data[idx+2] = Math.min(255, Math.max(0, data[idx+2] * (1 + noiseValue)));\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, 0);\n      \n      // Add subtle scratches\n      this.addScratchesOverlay(canvas, ctx);\n    } catch (e) {\n      console.warn('Error in addBrushedMetalTexture:', e);\n    }\n  }\n  \n  addScratchesOverlay(canvas, ctx) {\n    try {\n      const size = canvas.width;\n      \n      // Draw some subtle scratches\n      ctx.strokeStyle = 'rgba(255,255,255,0.07)';\n      ctx.lineWidth = 1;\n      \n      for (let i = 0; i < 20; i++) {\n        const x1 = Math.random() * size;\n        const y1 = Math.random() * size;\n        const length = 50 + Math.random() * 100;\n        const angle = Math.random() * Math.PI;\n        \n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1 + Math.cos(angle) * length, y1 + Math.sin(angle) * length);\n        ctx.stroke();\n      }\n      \n      // Add a few deeper scratches\n      ctx.strokeStyle = 'rgba(0,0,0,0.05)';\n      for (let i = 0; i < 5; i++) {\n        const x1 = Math.random() * size;\n        const y1 = Math.random() * size;\n        const length = 20 + Math.random() * 80;\n        const angle = Math.random() * Math.PI;\n        \n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1 + Math.cos(angle) * length, y1 + Math.sin(angle) * length);\n        ctx.stroke();\n      }\n    } catch (e) {\n      console.warn('Error in addScratchesOverlay:', e);\n    }\n  }\n\n  createEnvironmentMap() {\n    // We're using the HDR environment map loaded in main.js\n    // No local fallback environment map needed anymore\n  }\n  \n  setupLightProbe() {\n    // Create a light probe to enhance reflections with realistic light\n    if (THREE.LightProbe) {\n      this.lightProbe = new THREE.LightProbe();\n      this.lightProbe.intensity = 1.0;\n      this.scene.add(this.lightProbe);\n    }\n    \n    // Add ambient and direct lights regardless\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);\n    const directLight = new THREE.DirectionalLight(0xffffff, 0.7);\n    directLight.position.set(1, 1, 1);\n    \n    this.scene.add(ambientLight);\n    this.scene.add(directLight);\n  }\n  */\n\n  createMesh() {\n    // Determine chip size based on config\n    const chipWidth = config.chipWidth * (1 - config.chipSpacing);\n    const chipHeight = config.chipHeight * (1 - config.chipSpacing);\n    const chipDepth = config.chipDepth;\n    const cornerRadius = config.roundedCorners ? 0.1 : 0;\n    \n    // Use appropriate geometry based on config\n    let geometry;\n    \n    try {\n      if (config.roundedCorners && RoundedBoxGeometry) {\n        geometry = new RoundedBoxGeometry(chipWidth, chipHeight, chipDepth, 8, cornerRadius);\n      } else if (config.beveledCorners && MeshBeveledBoxGeometry) {\n        geometry = new MeshBeveledBoxGeometry(chipWidth, chipHeight, chipDepth, 3, 0.05);\n      } else {\n        geometry = new THREE.BoxGeometry(chipWidth, chipHeight, chipDepth);\n      }\n    } catch (e) {\n      // Fallback to basic geometry\n      geometry = new THREE.BoxGeometry(chipWidth, chipHeight, chipDepth);\n    }\n    \n    // Create material with improved reflectivity and transparency\n    // Using settings closer to silver-3d-rectangle for guaranteed visibility\n    const material = new THREE.MeshPhysicalMaterial({\n      color: new THREE.Color(config.baseColor),\n      metalness: 0.9,          // Higher metalness for better visibility (closer to silver-3d-rectangle's 1.0)\n      roughness: 0.1,          // Low for more reflection\n      reflectivity: 1.0,       // Maximum reflectivity\n      envMapIntensity: 1.5,    // Higher intensity for more visible reflections\n      transmission: 0.2,       // Reduced from 0.8 for better visibility\n      thickness: 0.5,          // For glass refraction\n      transparent: true,       // Enable transparency\n      opacity: 0.9,            // Higher opacity for better visibility\n      premultipliedAlpha: true // Match silver-3d-rectangle's approach\n    });\n    \n    // Create the mesh\n    this.mesh = new THREE.Mesh(geometry, material);\n    \n    // Add slight rotation for more reflection angles\n    this.mesh.rotation.set(\n      Math.random() * 0.05 - 0.025,\n      Math.random() * 0.05 - 0.025,\n      Math.random() * 0.05 - 0.025\n    );\n  }\n  \n  updatePosition() {\n    // Get uniform grid layout\n    const gridSize = config.gridSize;\n    const spacing = config.gridSpacing;\n    \n    // Calculate position in the grid (centered)\n    const x = (this.col - (gridSize - 1) / 2) * spacing;\n    const y = ((gridSize - 1) / 2 - this.row) * spacing;\n    const z = 0;\n    \n    // Update initial position\n    this.initialPosition.set(x, y, z);\n    this.mesh.position.copy(this.initialPosition);\n    \n    // Update hover position\n    this.hoverPosition.set(x, y, z + config.hoverLift);\n  }\n  \n  update(time) {\n    if (!this.mesh) return;\n    \n    // Subtle floating animation\n    if (!this.isHovered) {\n      // Offset the time based on position to create a wave-like effect\n      const timeOffset = this.row * 0.2 + this.col * 0.3;\n      const floatHeight = Math.sin((time + timeOffset) * config.floatSpeed) * config.floatAmplitude;\n      \n      this.mesh.position.z = this.initialPosition.z + floatHeight;\n      \n      // Subtle rotation for more dynamism\n      this.mesh.rotation.x = Math.sin(time * 0.2 + this.row * 0.5) * 0.03;\n      this.mesh.rotation.y = Math.cos(time * 0.3 + this.col * 0.5) * 0.03;\n    }\n  }\n  \n  onHover(isHovered) {\n    if (this.isHovered === isHovered) return;\n    \n    this.isHovered = isHovered;\n    \n    // Skip animations if gsap is not available\n    if (typeof gsap === 'undefined') return;\n    \n    // Handle hover animation\n    if (isHovered) {\n      // Move up on hover\n      gsap.to(this.mesh.position, {\n        x: this.hoverPosition.x,\n        y: this.hoverPosition.y,\n        z: this.hoverPosition.z,\n        duration: 0.3,\n        ease: 'power2.out'\n      });\n      \n      // Scale up slightly on hover\n      gsap.to(this.mesh.scale, {\n        x: this.hoverScale.x,\n        y: this.hoverScale.y,\n        z: this.hoverScale.z,\n        duration: 0.3,\n        ease: 'power2.out'\n      });\n      \n      // Make material more reflective\n      gsap.to(this.mesh.material, {\n        envMapIntensity: 2.0,\n        emissiveIntensity: 0.5,\n        duration: 0.3\n      });\n      \n      // Add soft emissive glow when hovered\n      if (!this.mesh.material.emissive) this.mesh.material.emissive = new THREE.Color(0x333333);\n      gsap.to(this.mesh.material, {\n        emissiveIntensity: 0.5,\n        duration: 0.3\n      });\n    } else {\n      // Return to original position\n      gsap.to(this.mesh.position, {\n        x: this.initialPosition.x,\n        y: this.initialPosition.y,\n        z: this.initialPosition.z,\n        duration: 0.5,\n        ease: 'power2.out'\n      });\n      \n      // Return to original scale\n      gsap.to(this.mesh.scale, {\n        x: this.originalScale.x,\n        y: this.originalScale.y,\n        z: this.originalScale.z,\n        duration: 0.5,\n        ease: 'power2.out'\n      });\n      \n      // Reset material to normal properties\n      gsap.to(this.mesh.material, {\n        envMapIntensity: 1.0,\n        emissiveIntensity: 0,\n        duration: 0.5\n      });\n    }\n  }\n  \n  onClick() {\n    this.isAccented = !this.isAccented;\n    \n    // Skip animations if gsap is not available\n    if (typeof gsap === 'undefined') {\n      this.mesh.material.color.set(this.isAccented ? config.accentColor : config.baseColor);\n      return;\n    }\n    \n    if (this.isAccented) {\n      // Change to accent color\n      gsap.to(this.mesh.material.color, {\n        r: config.accentColor.r,\n        g: config.accentColor.g,\n        b: config.accentColor.b,\n        duration: 0.3\n      });\n    } else {\n      // Change back to base color\n      gsap.to(this.mesh.material.color, {\n        r: config.baseColor.r,\n        g: config.baseColor.g,\n        b: config.baseColor.b,\n        duration: 0.3\n      });\n    }\n  }\n  \n  dispose() {\n    if (this.mesh) {\n      if (this.mesh.geometry) {\n        this.mesh.geometry.dispose();\n      }\n      \n      if (this.mesh.material) {\n        this.mesh.material.dispose();\n      }\n      \n      this.scene.remove(this.mesh);\n      this.mesh = null;\n    }\n  }\n}\n\nexport default Chip;"]}