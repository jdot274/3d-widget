{"version":3,"sources":["Chip.js"],"names":["Chip","row","col","scene","isHovered","isAccented","initialPosition","THREE","Vector3","hoverPosition","config","hoverLift","originalScale","hoverScale","createMesh","updatePosition","mesh","userData","chip","originalPosition","position","clone","add","chipWidth","chipSpacing","chipHeight","chipDepth","cornerRadius","roundedCorners","geometry","RoundedBoxGeometry","beveledCorners","MeshBeveledBoxGeometry","BoxGeometry","e","material","MeshPhysicalMaterial","color","Color","baseColor","metalness","roughness","reflectivity","envMapIntensity","transmission","thickness","transparent","opacity","premultipliedAlpha","Mesh","rotation","set","Math","random","gridSize","spacing","gridSpacing","x","y","z","copy","time","timeOffset","floatHeight","sin","floatSpeed","floatAmplitude","cos","gsap","to","duration","ease","scale","emissiveIntensity","emissive","accentColor","r","g","b","dispose","remove"],"mappings":"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","sourcesContent":["import * as THREE from 'three';\nimport config from '../scene.config.json';\n// Import with proper fallbacks - using synchronous imports for guaranteed loading\nimport { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';\nimport { MeshBeveledBoxGeometry } from './geometries/MeshBeveledBoxGeometry.js';\n\nclass Chip {\n  constructor(row, col, scene) {\n    this.row = row;\n    this.col = col;\n    this.scene = scene;\n    this.isHovered = false;\n    this.isAccented = false;\n    this.initialPosition = new THREE.Vector3(0, 0, 0);\n    this.hoverPosition = new THREE.Vector3(0, 0, config.hoverLift * 2);\n    this.originalScale = new THREE.Vector3(1, 1, 1);\n    this.hoverScale = new THREE.Vector3(1.1, 1.1, 1.1);\n    \n    // Create mesh with appropriate geometry and material\n    this.createMesh();\n    \n    // Position the mesh in the scene\n    this.updatePosition();\n    \n    // Save original position for animations\n    this.mesh.userData.chip = this;\n    this.mesh.userData.originalPosition = this.mesh.position.clone();\n    \n    // Add to scene\n    scene.add(this.mesh);\n  }\n\n  /*\n  loadMatcap() {\n    // Use a matcap texture for more realistic metal\n    try {\n      const textureLoader = new THREE.TextureLoader();\n      this.matcapTexture = this.createMatcapTexture(); // Start with the local version\n      \n      // Try to load a remote texture but don't fail if it doesn't work\n      textureLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/dancing_hall_1k.hdr', \n        // Success callback\n        (texture) => {\n          this.matcapTexture = texture;\n          if (this.material) {\n            this.material.envMap = texture;\n            this.material.needsUpdate = true;\n          }\n        },\n        // Progress callback\n        undefined,\n        // Error callback\n        (err) => {\n          console.warn('Failed to load external texture, using local fallback');\n        }\n      );\n    } catch (e) {\n      console.warn('Error in loadMatcap:', e);\n      this.matcapTexture = this.createMatcapTexture();\n    }\n  }\n  \n  createMatcapTexture() {\n    // Create a custom matcap texture for brushed metal\n    try {\n      const size = 1024;\n      const canvas = document.createElement('canvas');\n      canvas.width = size;\n      canvas.height = size;\n      const ctx = canvas.getContext('2d');\n      \n      // Create a radial gradient for a silver matcap\n      const gradient = ctx.createRadialGradient(\n        size * 0.4, size * 0.4, 0,\n        size * 0.5, size * 0.5, size * 0.7\n      );\n      \n      // Silver matcap with highlight\n      gradient.addColorStop(0, '#ffffff');\n      gradient.addColorStop(0.2, '#f0f0f0');\n      gradient.addColorStop(0.4, '#d0d0d0');\n      gradient.addColorStop(0.7, '#a0a0a0');\n      gradient.addColorStop(1, '#808080');\n      \n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, size, size);\n      \n      // Add brushed metal texture using noise lines\n      this.addBrushedMetalTexture(canvas, ctx, 0.1);\n      \n      // Create a texture from the canvas\n      const texture = new THREE.CanvasTexture(canvas);\n      texture.needsUpdate = true;\n      \n      return texture;\n    } catch (e) {\n      console.warn('Error in createMatcapTexture:', e);\n      return null;\n    }\n  }\n  \n  addBrushedMetalTexture(canvas, ctx, intensity) {\n    try {\n      const size = canvas.width;\n      const imageData = ctx.getImageData(0, 0, size, size);\n      const data = imageData.data;\n      \n      // Create brushed metal effect with horizontal lines\n      for (let y = 0; y < size; y++) {\n        // Vary the intensity slightly per line for more natural look\n        const lineIntensity = intensity * (0.8 + Math.random() * 0.4);\n        \n        // Create a noise pattern for this line\n        const noisePattern = [];\n        for (let x = 0; x < size / 10; x++) {\n          noisePattern.push((Math.random() - 0.5) * lineIntensity);\n        }\n        \n        for (let x = 0; x < size; x++) {\n          const idx = (y * size + x) * 4;\n          // Use interpolated noise for smoother brushed effect\n          const noiseIdx = Math.floor(x / 10);\n          const noiseValue = noisePattern[noiseIdx % noisePattern.length];\n          \n          data[idx] = Math.min(255, Math.max(0, data[idx] * (1 + noiseValue)));\n          data[idx+1] = Math.min(255, Math.max(0, data[idx+1] * (1 + noiseValue)));\n          data[idx+2] = Math.min(255, Math.max(0, data[idx+2] * (1 + noiseValue)));\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, 0);\n      \n      // Add subtle scratches\n      this.addScratchesOverlay(canvas, ctx);\n    } catch (e) {\n      console.warn('Error in addBrushedMetalTexture:', e);\n    }\n  }\n  \n  addScratchesOverlay(canvas, ctx) {\n    try {\n      const size = canvas.width;\n      \n      // Draw some subtle scratches\n      ctx.strokeStyle = 'rgba(255,255,255,0.07)';\n      ctx.lineWidth = 1;\n      \n      for (let i = 0; i < 20; i++) {\n        const x1 = Math.random() * size;\n        const y1 = Math.random() * size;\n        const length = 50 + Math.random() * 100;\n        const angle = Math.random() * Math.PI;\n        \n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1 + Math.cos(angle) * length, y1 + Math.sin(angle) * length);\n        ctx.stroke();\n      }\n      \n      // Add a few deeper scratches\n      ctx.strokeStyle = 'rgba(0,0,0,0.05)';\n      for (let i = 0; i < 5; i++) {\n        const x1 = Math.random() * size;\n        const y1 = Math.random() * size;\n        const length = 20 + Math.random() * 80;\n        const angle = Math.random() * Math.PI;\n        \n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1 + Math.cos(angle) * length, y1 + Math.sin(angle) * length);\n        ctx.stroke();\n      }\n    } catch (e) {\n      console.warn('Error in addScratchesOverlay:', e);\n    }\n  }\n\n  createEnvironmentMap() {\n    // We're using the HDR environment map loaded in main.js\n    // No local fallback environment map needed anymore\n  }\n  \n  setupLightProbe() {\n    // Create a light probe to enhance reflections with realistic light\n    if (THREE.LightProbe) {\n      this.lightProbe = new THREE.LightProbe();\n      this.lightProbe.intensity = 1.0;\n      this.scene.add(this.lightProbe);\n    }\n    \n    // Add ambient and direct lights regardless\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);\n    const directLight = new THREE.DirectionalLight(0xffffff, 0.7);\n    directLight.position.set(1, 1, 1);\n    \n    this.scene.add(ambientLight);\n    this.scene.add(directLight);\n  }\n  */\n\n  createMesh() {\n    // Determine chip size based on config\n    const chipWidth = config.chipWidth * (1 - config.chipSpacing);\n    const chipHeight = config.chipHeight * (1 - config.chipSpacing);\n    const chipDepth = config.chipDepth;\n    const cornerRadius = config.roundedCorners ? 0.1 : 0;\n    \n    // Use appropriate geometry based on config\n    let geometry;\n    \n    try {\n      if (config.roundedCorners && RoundedBoxGeometry) {\n        geometry = new RoundedBoxGeometry(chipWidth, chipHeight, chipDepth, 8, cornerRadius);\n      } else if (config.beveledCorners && MeshBeveledBoxGeometry) {\n        geometry = new MeshBeveledBoxGeometry(chipWidth, chipHeight, chipDepth, 3, 0.05);\n      } else {\n        geometry = new THREE.BoxGeometry(chipWidth, chipHeight, chipDepth);\n      }\n    } catch (e) {\n      // Fallback to basic geometry\n      geometry = new THREE.BoxGeometry(chipWidth, chipHeight, chipDepth);\n    }\n    \n    // Create material with improved reflectivity and transparency\n    // Using settings closer to silver-3d-rectangle for guaranteed visibility\n    const material = new THREE.MeshPhysicalMaterial({\n      color: new THREE.Color(config.baseColor),\n      metalness: 0.9,          // Higher metalness for better visibility (closer to silver-3d-rectangle's 1.0)\n      roughness: 0.1,          // Low for more reflection\n      reflectivity: 1.0,       // Maximum reflectivity\n      envMapIntensity: 1.5,    // Higher intensity for more visible reflections\n      transmission: 0.2,       // Reduced from 0.8 for better visibility\n      thickness: 0.5,          // For glass refraction\n      transparent: true,       // Enable transparency\n      opacity: 0.9,            // Higher opacity for better visibility\n      premultipliedAlpha: true // Match silver-3d-rectangle's approach\n    });\n    \n    // Create the mesh\n    this.mesh = new THREE.Mesh(geometry, material);\n    \n    // Add slight rotation for more reflection angles\n    this.mesh.rotation.set(\n      Math.random() * 0.05 - 0.025,\n      Math.random() * 0.05 - 0.025,\n      Math.random() * 0.05 - 0.025\n    );\n  }\n  \n  updatePosition() {\n    // Get uniform grid layout\n    const gridSize = config.gridSize;\n    const spacing = config.gridSpacing;\n    \n    // Calculate position in the grid (centered)\n    const x = (this.col - (gridSize - 1) / 2) * spacing;\n    const y = ((gridSize - 1) / 2 - this.row) * spacing;\n    const z = 0;\n    \n    // Update initial position\n    this.initialPosition.set(x, y, z);\n    this.mesh.position.copy(this.initialPosition);\n    \n    // Update hover position\n    this.hoverPosition.set(x, y, z + config.hoverLift);\n  }\n  \n  update(time) {\n    if (!this.mesh) return;\n    \n    // Subtle floating animation\n    if (!this.isHovered) {\n      // Offset the time based on position to create a wave-like effect\n      const timeOffset = this.row * 0.2 + this.col * 0.3;\n      const floatHeight = Math.sin((time + timeOffset) * config.floatSpeed) * config.floatAmplitude;\n      \n      this.mesh.position.z = this.initialPosition.z + floatHeight;\n      \n      // Subtle rotation for more dynamism\n      this.mesh.rotation.x = Math.sin(time * 0.2 + this.row * 0.5) * 0.03;\n      this.mesh.rotation.y = Math.cos(time * 0.3 + this.col * 0.5) * 0.03;\n    }\n  }\n  \n  onHover(isHovered) {\n    if (this.isHovered === isHovered) return;\n    \n    this.isHovered = isHovered;\n    \n    // Skip animations if gsap is not available\n    if (typeof gsap === 'undefined') return;\n    \n    // Handle hover animation\n    if (isHovered) {\n      // Move up on hover\n      gsap.to(this.mesh.position, {\n        x: this.hoverPosition.x,\n        y: this.hoverPosition.y,\n        z: this.hoverPosition.z,\n        duration: 0.3,\n        ease: 'power2.out'\n      });\n      \n      // Scale up slightly on hover\n      gsap.to(this.mesh.scale, {\n        x: this.hoverScale.x,\n        y: this.hoverScale.y,\n        z: this.hoverScale.z,\n        duration: 0.3,\n        ease: 'power2.out'\n      });\n      \n      // Make material more reflective\n      gsap.to(this.mesh.material, {\n        envMapIntensity: 2.0,\n        emissiveIntensity: 0.5,\n        duration: 0.3\n      });\n      \n      // Add soft emissive glow when hovered\n      if (!this.mesh.material.emissive) this.mesh.material.emissive = new THREE.Color(0x333333);\n      gsap.to(this.mesh.material, {\n        emissiveIntensity: 0.5,\n        duration: 0.3\n      });\n    } else {\n      // Return to original position\n      gsap.to(this.mesh.position, {\n        x: this.initialPosition.x,\n        y: this.initialPosition.y,\n        z: this.initialPosition.z,\n        duration: 0.5,\n        ease: 'power2.out'\n      });\n      \n      // Return to original scale\n      gsap.to(this.mesh.scale, {\n        x: this.originalScale.x,\n        y: this.originalScale.y,\n        z: this.originalScale.z,\n        duration: 0.5,\n        ease: 'power2.out'\n      });\n      \n      // Reset material to normal properties\n      gsap.to(this.mesh.material, {\n        envMapIntensity: 1.0,\n        emissiveIntensity: 0,\n        duration: 0.5\n      });\n    }\n  }\n  \n  onClick() {\n    this.isAccented = !this.isAccented;\n    \n    // Skip animations if gsap is not available\n    if (typeof gsap === 'undefined') {\n      this.mesh.material.color.set(this.isAccented ? config.accentColor : config.baseColor);\n      return;\n    }\n    \n    if (this.isAccented) {\n      // Change to accent color\n      gsap.to(this.mesh.material.color, {\n        r: config.accentColor.r,\n        g: config.accentColor.g,\n        b: config.accentColor.b,\n        duration: 0.3\n      });\n    } else {\n      // Change back to base color\n      gsap.to(this.mesh.material.color, {\n        r: config.baseColor.r,\n        g: config.baseColor.g,\n        b: config.baseColor.b,\n        duration: 0.3\n      });\n    }\n  }\n  \n  dispose() {\n    if (this.mesh) {\n      if (this.mesh.geometry) {\n        this.mesh.geometry.dispose();\n      }\n      \n      if (this.mesh.material) {\n        this.mesh.material.dispose();\n      }\n      \n      this.scene.remove(this.mesh);\n      this.mesh = null;\n    }\n  }\n}\n\nexport default Chip;"],"file":"Chip.dev.js"}